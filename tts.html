<!DOCTYPE html>
<!-- maybe working tts reader ok -->
<html lang="en">
  <head>
    <title>NobiteK - TTS Reader</title>
    <meta charset="UTF-8">
    <meta name="description" content="ðŸ’€">
    <meta name="keywords" content="nobitek, nobiteek, norbitek">
    <meta name="author" content="NobiteK">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="darkreader-lock">
    <meta property="og:type" content="site">
    <meta property="og:title" content="NobiteK - TTS Reader">
    <meta property="og:description" content="ðŸ’€">
    <meta itemprop="name" content="NobiteK - TTS Reader">
    <meta itemprop="description" content="ðŸ’€">
    <meta itemprop="image" content="/assets/Images/Icon.png">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#5d35b2">
    <link rel="shortcut icon" href="/assets/Images/Icon.png" type="image/x-icon">
    <link rel="stylesheet" href="/assets/css/stylesheet.css">
    <style>
    :root {
        --primary-color:#4dabf7; --secondary-color:#339af0;
        --background-color:#121212; --card-color:#1e1e1e;
        --text-color:#e0e0e0; --border-color:#333;
        --border-radius:8px; --input-bg:#2d2d2d;
    }

    * {margin:0; padding:0; box-sizing:border-box; font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;}
    body {background-color:var(--background-color); color:var(--text-color); padding:12px; min-height:100vh; display:flex; flex-direction:column;}
    .container {max-width:600px; margin:0 auto; width:100%;}
    header {text-align:center; margin-bottom:20px; padding:15px 5px;}
    h1 {color:var(--primary-color); margin-bottom:10px; font-size:24px;}
    .subtitle {color:#888; margin-bottom:10px; font-size:14px;}
    .card {background-color:var(--card-color); border-radius:var(--border-radius); box-shadow:0 4px 6px rgba(0,0,0,0.3); padding:15px; margin-bottom:20px; border:1px solid var(--border-color);}
    .controls {display:grid; grid-template-columns:repeat(3,1fr); gap:8px; margin-bottom:15px;}
    button {background-color:var(--primary-color); color:white; border:none; padding:12px 8px; border-radius:var(--border-radius); cursor:pointer; font-size:16px; transition:all 0.2s ease;}
    button:hover {background-color:var(--secondary-color);}
    button:active {transform:scale(0.95); background-color:var(--secondary-color);}
    button:disabled {background-color:#444; color:#777; cursor:not-allowed;}
    button.secondary {background-color:#555;}
    button.secondary:hover {background-color:#666;}
    button.secondary:active {transform:scale(0.95); background-color:#666;}
    .settings {margin-bottom:15px;}
    .setting-row {display:flex; align-items:center; margin-bottom:12px; gap:10px;}
    label {font-weight:bold; min-width:60px;}
    select, input[type="range"] {padding:8px; border-radius:var(--border-radius); border:1px solid var(--border-color); background-color:var(--input-bg); color:var(--text-color); flex-grow:1;}
    input[type="range"] {padding:0; background-color:var(--border-color); height:6px;}
    input[type="range"]::-webkit-slider-thumb {background:var(--primary-color);}
    input[type="range"]::-moz-range-thumb {background:var(--primary-color);}
    .checkbox-container {display:flex; align-items:center; gap:8px; user-select:none;}
    input[type="checkbox"] {width:18px; height:18px; cursor:pointer;}
    textarea {width:100%; height:180px; padding:12px; border-radius:var(--border-radius); border:1px solid var(--border-color); background-color:var(--input-bg); color:var(--text-color); resize:vertical; font-size:16px; line-height:1.5; margin-bottom:15px;}
    .status {font-style:italic; color:#888; margin-top:8px; font-size:14px;}
    footer {text-align:center; margin-top:auto; padding:15px; color:#888; font-size:12px;}

@media(max-width:480px){
    body {padding:8px;}
    .card {padding:12px;}
    button {padding:10px 5px; font-size:14px;}
    textarea {height:150px; font-size:14px;}
    .settings {margin-bottom:12px;}
    .setting-row {margin-bottom:10px;}
}
</style>
</head>

<header>
<div id="burger" onclick="enable()">
    <span></span>
    <span></span>
    <span></span>
    <span></span>
</div>
  <nav class="nav" id="nav">
    <li><a href="/">Home</a></li>
    <li><a href="/tts">TTS</a></li>
  </nav>
</header>

<body>
    <div class="container">
        <header>
            <h1></h1>
        </header>

        <main>
            <div class="card">
                <div class="controls">
                    <button id="playBtn" title="Play">Play</button>
                    <button id="pauseBtn" title="Pause" disabled>Pause</button>
                    <button id="stopBtn" title="Stop" disabled>Stop</button>
                </div>

                <div class="settings">
                    <div class="setting-row">
                        <label for="voice">Voice:</label>
                        <select id="voice"></select>
                    </div>
                    <div class="setting-row">
                        <label for="rate">Speed:</label>
                        <input type="range" id="rate" min="0.5" max="2" value="1" step="0.1">
                        <span id="rateValue">1.0</span>
                    </div>
                    <div class="setting-row">
                        <label for="volume">Volume:</label>
                        <input type="range" id="volume" min="0" max="1" value="1" step="0.1">
                        <span id="volumeValue">1.0</span>
                    </div>
                    <div class="setting-row">
                        <div class="checkbox-container">
                            <input type="checkbox" id="infiniteRepeat">
                            <label for="infiniteRepeat">Infinite Repeat</label>
                        </div>
                    </div>
                    <div class="setting-row">
                        <div class="checkbox-container">
                            <input type="checkbox" id="wakeLockToggle">
                            <label for="wakeLockToggle">Keep Screen On</label>
                        </div>
                    </div>
                </div>

                <textarea id="textInput" placeholder="Enter the text you want to convert to speech here..."></textarea>
                <div class="status" id="status">Ready to speak</div>
            </div>
        </main>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const playBtn = document.getElementById('playBtn');
            const pauseBtn = document.getElementById('pauseBtn');
            const stopBtn = document.getElementById('stopBtn');
            const textInput = document.getElementById('textInput');
            const voiceSelect = document.getElementById('voice');
            const rateInput = document.getElementById('rate');
            const volumeInput = document.getElementById('volume');
            const infiniteRepeatCheckbox = document.getElementById('infiniteRepeat');
            const wakeLockToggle = document.getElementById('wakeLockToggle');
            const rateValue = document.getElementById('rateValue');
            const volumeValue = document.getElementById('volumeValue');
            const status = document.getElementById('status');

            const synth = window.speechSynthesis;
            let utterance = null;
            let voices = [];
            let isPaused = false;
            let currentRepeat = 0;
            let isInfiniteRepeat = false;
            let currentText = '';
            let wakeLock = null;
            let isWakeLockEnabled = false;

            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);

            const allowedVoices = [
                { name: "Google polski", lang: "pl-PL" },
                { name: "Google US English", lang: "en-US" },
                { name: "Google Ñ€ÑƒÑÑÐºÐ¸Ð¹", lang: "ru-RU" }
            ];

            // Wake Lock API functions
            async function requestWakeLock() {
                if ('wakeLock' in navigator && !wakeLock) {
                    try {
                        wakeLock = await navigator.wakeLock.request('screen');
                        isWakeLockEnabled = true;
                        console.log('Wake lock activated');
                        
                        wakeLock.addEventListener('release', () => {
                            console.log('Wake lock released');
                            wakeLock = null;
                            isWakeLockEnabled = false;
                            wakeLockToggle.checked = false;
                        });
                        
                    } catch (err) {
                        console.error('Wake lock failed:', err);
                        wakeLockToggle.checked = false;
                        updateStatus('Wake lock not supported or failed');
                    }
                }
            }

            async function releaseWakeLock() {
                if (wakeLock) {
                    try {
                        await wakeLock.release();
                        wakeLock = null;
                        isWakeLockEnabled = false;
                        console.log('Wake lock released manually');
                    } catch (err) {
                        console.error('Failed to release wake lock:', err);
                    }
                }
            }

            // Handle wake lock toggle
            wakeLockToggle.addEventListener('change', async function() {
                if (this.checked) {
                    await requestWakeLock();
                } else {
                    await releaseWakeLock();
                }
            });

            // Re-acquire wake lock when page becomes visible again
            document.addEventListener('visibilitychange', async () => {
                if (!document.hidden && wakeLockToggle.checked && !wakeLock) {
                    await requestWakeLock();
                }
            });

            // iOS-specific background audio techniques
            function setupiOSBackgroundAudio() {
                if (isIOS) {
                    // Create a silent audio context to keep audio thread alive
                    try {
                        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        
                        // Set volume to 0 (silent)
                        gainNode.gain.value = 0;
                        oscillator.frequency.value = 440;
                        
                        // Keep a very quiet tone playing to maintain audio context
                        oscillator.start();
                        
                        // Store references
                        window.audioContext = audioContext;
                        window.silentOscillator = oscillator;
                        window.silentGainNode = gainNode;
                        
                        console.log('iOS background audio context setup');
                    } catch (err) {
                        console.error('Failed to setup iOS background audio:', err);
                    }
                }
            }

            function enableiOSBackgroundMode() {
                if (isIOS) {
                    // Attempt to enable background mode by making a brief audio play
                    const audio = new Audio('data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAAAQAwAAEAAAAABAAgAZGF0YQQAAAAAAA==');
                    audio.volume = 0.01;
                    audio.play().catch(err => console.log('Silent audio play failed:', err));
                }
            }

            // Initialize Media Session API
            function initializeMediaSession() {
                if ('mediaSession' in navigator) {
                    // Set metadata that will be displayed in lock screen/notification
                    navigator.mediaSession.metadata = new MediaMetadata({
                        title: 'Text-to-Speech',
                        artist: 'NobiteK TTS Reader',
                        album: 'Voice Synthesis',
                        artwork: [
                            { src: '/assets/Images/Icon.png', sizes: '96x96', type: 'image/png' },
                            { src: '/assets/Images/Icon.png', sizes: '128x128', type: 'image/png' },
                            { src: '/assets/Images/Icon.png', sizes: '192x192', type: 'image/png' },
                            { src: '/assets/Images/Icon.png', sizes: '256x256', type: 'image/png' },
                            { src: '/assets/Images/Icon.png', sizes: '384x384', type: 'image/png' },
                            { src: '/assets/Images/Icon.png', sizes: '512x512', type: 'image/png' }
                        ]
                    });

                    // Set up action handlers for media controls
                    navigator.mediaSession.setActionHandler('play', () => {
                        if (isPaused && synth.paused) {
                            synth.resume();
                            isPaused = false;
                            speakingUI();
                            navigator.mediaSession.playbackState = 'playing';
                        } else {
                            speak();
                        }
                    });

                    navigator.mediaSession.setActionHandler('pause', () => {
                        if (synth.speaking && !synth.paused) {
                            synth.pause();
                            isPaused = true;
                            pausedUI();
                            navigator.mediaSession.playbackState = 'paused';
                        }
                    });

                    navigator.mediaSession.setActionHandler('stop', () => {
                        stop();
                        navigator.mediaSession.playbackState = 'none';
                    });

                    // Optional: Handle next/previous if you want to add functionality
                    navigator.mediaSession.setActionHandler('nexttrack', () => {
                        // You could implement skip functionality here
                        console.log('Next track requested');
                    });

                    navigator.mediaSession.setActionHandler('previoustrack', () => {
                        // You could implement previous functionality here
                        console.log('Previous track requested');
                    });
                }
            }

            function updateMediaSessionMetadata(text) {
                if ('mediaSession' in navigator) {
                    const truncatedText = text.length > 50 ? text.substring(0, 50) + '...' : text;
                    navigator.mediaSession.metadata = new MediaMetadata({
                        title: truncatedText,
                        artist: 'NobiteK TTS Reader',
                        album: `Voice: ${voices[voiceSelect.value]?.name || 'Default'}`,
                        artwork: [
                            { src: '/assets/Images/Icon.png', sizes: '96x96', type: 'image/png' },
                            { src: '/assets/Images/Icon.png', sizes: '128x128', type: 'image/png' },
                            { src: '/assets/Images/Icon.png', sizes: '192x192', type: 'image/png' },
                            { src: '/assets/Images/Icon.png', sizes: '256x256', type: 'image/png' },
                            { src: '/assets/Images/Icon.png', sizes: '384x384', type: 'image/png' },
                            { src: '/assets/Images/Icon.png', sizes: '512x512', type: 'image/png' }
                        ]
                    });
                }
            }

            function loadVoices() {
                const allVoices = synth.getVoices();
                
                if (allVoices.length === 0) {
                    return;
                }
                
                if (isIOS) {
                    voices = allVoices.filter(voice => {
                        return voice.lang.startsWith('pl-') || 
                               voice.lang.startsWith('en-') || 
                               voice.lang.startsWith('ru-');
                    });
                } else {
                    voices = allVoices.filter(voice => {
                        return allowedVoices.some(allowed => 
                            voice.name.includes(allowed.name) && 
                            voice.lang.includes(allowed.lang) &&
                            !voice.name.includes("UK")
                        );
                    });
                    
                    if (voices.length === 0) {
                        voices = allVoices;
                    }
                }
                
                voiceSelect.innerHTML = '';
                
                voices.forEach((voice, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = `${voice.name}`;
                    voiceSelect.appendChild(option);
                });
            }

            function waitForVoices() {
                return new Promise((resolve) => {
                    const checkVoices = () => {
                        const allVoices = synth.getVoices();
                        if (allVoices.length > 0) {
                            resolve();
                        } else {
                            setTimeout(checkVoices, 100);
                        }
                    };
                    checkVoices();
                });
            }

            if (synth.onvoiceschanged !== undefined) {
                synth.onvoiceschanged = loadVoices;
            }
            
            waitForVoices().then(() => {
                loadVoices();
                initializeMediaSession();
                setupiOSBackgroundAudio();
            });

            function updateStatus(message) {
                status.textContent = message;
            }

            function resetUI() {
                playBtn.disabled = false;
                pauseBtn.disabled = true;
                stopBtn.disabled = true;
                updateStatus('Ready to speak');
                if ('mediaSession' in navigator) {
                    navigator.mediaSession.playbackState = 'none';
                }
                // Release wake lock when stopping
                if (wakeLock && !wakeLockToggle.checked) {
                    releaseWakeLock();
                }
            }

            function speakingUI() {
                playBtn.disabled = true;
                pauseBtn.disabled = false;
                stopBtn.disabled = false;
                
                if (isInfiniteRepeat) {
                    updateStatus(`Speaking... (Infinite mode: ${currentRepeat})`);
                } else {
                    updateStatus(`Speaking...`);
                }
                if ('mediaSession' in navigator) {
                    navigator.mediaSession.playbackState = 'playing';
                }
                
                // Request wake lock when speaking starts (if enabled)
                if (wakeLockToggle.checked && !wakeLock) {
                    requestWakeLock();
                }
            }

            function pausedUI() {
                playBtn.disabled = true;
                pauseBtn.disabled = true;
                stopBtn.disabled = false;
                
                if (isInfiniteRepeat) {
                    updateStatus(`Paused (Infinite mode: ${currentRepeat})`);
                } else {
                    updateStatus(`Paused`);
                }
                if ('mediaSession' in navigator) {
                    navigator.mediaSession.playbackState = 'paused';
                }
            }

            rateInput.addEventListener('input', function() {
                rateValue.textContent = parseFloat(this.value).toFixed(1);
            });

            volumeInput.addEventListener('input', function() {
                volumeValue.textContent = parseFloat(this.value).toFixed(1);
            });

            playBtn.addEventListener('click', function() {
                speak();
            });

            pauseBtn.addEventListener('click', function() {
                if (synth.speaking) {
                    synth.pause();
                    isPaused = true;
                    pausedUI();
                }
            });

            stopBtn.addEventListener('click', function() {
                stop();
            });

            function speak(isRepeat = false) {
                if (!isRepeat) {
                    currentRepeat = 1;
                    isInfiniteRepeat = infiniteRepeatCheckbox.checked;
                }

                if (synth.speaking && !isRepeat) {
                    synth.cancel();
                }

                const text = textInput.value.trim();
                if (!text) {
                    updateStatus('Please enter some text to speak');
                    return;
                }

                // Enable iOS background audio mode
                if (isIOS) {
                    enableiOSBackgroundMode();
                }

                currentText = text;
                updateMediaSessionMetadata(text);

                utterance = new SpeechSynthesisUtterance(text);

                const selectedVoice = voices[voiceSelect.value];
                if (selectedVoice) {
                    utterance.voice = selectedVoice;
                }

                utterance.rate = parseFloat(rateInput.value);
                utterance.volume = parseFloat(volumeInput.value);

                utterance.onstart = function() {
                    speakingUI();
                };

                utterance.onend = function() {
                    if (isInfiniteRepeat) {
                        currentRepeat++;
                        // Add a small delay to prevent iOS from stopping audio thread
                        setTimeout(() => {
                            if (isIOS) {
                                enableiOSBackgroundMode();
                            }
                            speak(true);
                        }, 500);
                    } else {
                        resetUI();
                    }
                };

                utterance.onerror = function(event) {
                    updateStatus('Error occurred: ' + event.error);
                    resetUI();
                };

                // iOS-specific: Try to maintain audio focus
                if (isIOS) {
                    utterance.onboundary = function(event) {
                        // Keep audio context alive during speech
                        if (window.audioContext && window.audioContext.state === 'suspended') {
                            window.audioContext.resume();
                        }
                    };
                }

                synth.speak(utterance);
            }

            function stop() {
                synth.cancel();
                isPaused = false;
                currentRepeat = 1;
                resetUI();
            }

            resetUI();
            initializeMediaSession();
        });
    </script>

</body>
  <script src="/assets/js/s.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.0/jquery.min.js"></script>
</html>
